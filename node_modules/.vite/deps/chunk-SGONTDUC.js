// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace(errorMessage, numberOfStackTraceLinesToRemove2) {
  let err;
  {
    var stackTraceLimit__original = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    err = new Error(errorMessage);
    Error.stackTraceLimit = stackTraceLimit__original;
  }
  err.stack = clean(err.stack, numberOfStackTraceLinesToRemove2);
  return err;
}
function clean(errStack, numberOfStackTraceLinesToRemove2) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove2 && isStackTraceLine(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine(line) {
  return line.startsWith("    at ");
}
function splitByLine(str) {
  return str.split(/\r?\n/);
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/getGlobalObject.js
function getGlobalObject(moduleKey, defaultValue) {
  const allGlobalObjects = globalThis.__telefunc = globalThis.__telefunc || {};
  const globalObject2 = allGlobalObjects[moduleKey] = allGlobalObjects[moduleKey] || defaultValue;
  return globalObject2;
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/projectInfo.js
var PROJECT_VERSION = "0.1.64";
var projectInfo = {
  projectName: "Telefunc",
  projectVersion: PROJECT_VERSION,
  npmPackageName: "telefunc",
  githubRepository: "https://github.com/brillout/telefunc",
  discordInviteToolChannel: "https://discord.com/invite/3DYWwk4xRQ"
};

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/assert.js
var errorPrefix = `[${projectInfo.npmPackageName}@${projectInfo.projectVersion}]`;
var internalErrorPrefix = `${errorPrefix}[Bug]`;
var usageErrorPrefix = `${errorPrefix}[Wrong Usage]`;
var warningPrefix = `${errorPrefix}[Warning]`;
var infoPrefix = `${errorPrefix}[Info]`;
var numberOfStackTraceLinesToRemove = 2;
function assert(condition, debugInfo) {
  if (condition) {
    return;
  }
  const debugStr = (() => {
    if (!debugInfo) {
      return "";
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : "`" + JSON.stringify(debugInfo) + "`";
    return `Debug info (this is for the ${projectInfo.projectName} maintainers; you can ignore this): ${debugInfoSerialized}.`;
  })();
  const internalError = createErrorWithCleanStackTrace([
    `${internalErrorPrefix} You stumbled upon a bug in ${projectInfo.projectName}'s source code.`,
    `Reach out at ${projectInfo.githubRepository}/issues/new or ${projectInfo.discordInviteToolChannel} and include this error stack (the error stack is usually enough to fix the problem).`,
    "A maintainer will fix the bug (usually under 24 hours).",
    `Don't hesitate to reach out as it makes ${projectInfo.projectName} more robust.`,
    debugStr
  ].join(" "), numberOfStackTraceLinesToRemove);
  throw internalError;
}
function assertUsage(condition, errorMessage) {
  if (condition) {
    return;
  }
  const whiteSpace = errorMessage.startsWith("[") ? "" : " ";
  const usageError = createErrorWithCleanStackTrace(`${usageErrorPrefix}${whiteSpace}${errorMessage}`, numberOfStackTraceLinesToRemove);
  throw usageError;
}
var globalObject = getGlobalObject("assert.ts", { alreadyLogged: /* @__PURE__ */ new Set() });
function assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {
  if (condition) {
    return;
  }
  const msg = `${warningPrefix} ${errorMessage}`;
  if (onlyOnce) {
    const { alreadyLogged } = globalObject;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged.has(key)) {
      return;
    } else {
      alreadyLogged.add(key);
    }
  }
  if (showStackTrace) {
    console.warn(new Error(msg));
  } else {
    console.warn(msg);
  }
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/isBrowser.js
function isBrowser() {
  const itIs = __browserTest();
  assert(itIs === !__nodeTest());
  return itIs;
}
function __nodeTest() {
  const nodeVersion = typeof process !== "undefined" && process && process.versions && process.versions.node;
  return !!nodeVersion;
}
function __browserTest() {
  return typeof window !== "undefined";
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/isObject.js
function isObject(value) {
  return typeof value === "object" && value !== null;
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/objectAssign.js
function objectAssign(obj, objAddendum) {
  Object.assign(obj, objAddendum);
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/lowercaseFirstLetter.js
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// .yarn/unplugged/telefunc-virtual-ccd523698d/node_modules/telefunc/dist/esm/utils/hasProp.js
function hasProp(obj, prop, type = "unknown") {
  const propExists = typeof obj === "object" && obj !== null && prop in obj;
  if (!propExists) {
    return false;
  }
  if (type === "unknown") {
    return true;
  }
  const propValue = obj[prop];
  if (type === "array") {
    return Array.isArray(propValue);
  }
  if (type === "string[]") {
    return Array.isArray(propValue) && propValue.every((el) => typeof el === "string");
  }
  if (type === "function") {
    return isCallable(propValue);
  }
  if (Array.isArray(type)) {
    return typeof propValue === "string" && type.includes(propValue);
  }
  if (type === "null") {
    return propValue === null;
  }
  if (type === "true") {
    return propValue === true;
  }
  return typeof propValue === type;
}

export {
  assert,
  assertUsage,
  assertWarning,
  isBrowser,
  isObject,
  objectAssign,
  lowercaseFirstLetter,
  hasProp
};
//# sourceMappingURL=chunk-SGONTDUC.js.map
